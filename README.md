# SpaceX
<p align="left">
  <img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/filtering.gif?raw=true" width="200"/>
  <img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/opening.gif?raw=true" width="200"/>
  <img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/scrolling.gif?raw=true" width="200"/>
  <img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/sorting.gif?raw=true" width="200"/>
</p>


## Dependency Managers

We get dependencies, we want to get into our app for multiple reasons like business reasons or to speed up something. Some of them are open source, Some of them are close source.

Historically, we use to have no dependency managers and just integrate things manually.

Getting the sources, dragging the Xcode project into your project some pre compiled binaries. If the dependency needs some setting like compiling flag we need to link them into the system

### CocoaPods

Coming up with CocoaPods, things get much easier. Use a podfile which is a text file, and run a command "pod install" and what he does behind doors it fetches all the sources for those dependencies, resolving all the versions and everything and puts into the Pod folder inside the project folder.

Also creating an Xcode project which creates the target for each of these dependencies and link them to your other targets.

Thus, when you make a build of your target, you implicitly also build all these dependencies.

### Swift Package Manager

Works through the Xcode interface, there is no file to add it. SPM also fetches the sources, but they keep them into a hidden folder, you don´t see it directly.

And you build them once, and then cache them locally. They will not be rebuilt unless you make a change like upgrading the version for example. You cannot access the files because they are locked in the hidden folder.

So, in the developer point of view it's great because you open the project for the first time and all these dependencies are fetched, then building the project you do not deal with that again because they are cached and reused between builds with a smooth experience I would say.

## Remove CocoaPods

Let’s remove CocoaPods from your project. You should run the command pod deintegrate in the same folder the Podfile is in. That command removes the Pods folder and removes the settings CocoaPods inserted in your .xcodeproj.

Now, run pod clean. That command will remove some leftover files like Podfile.lock and the .xcworkspace originally generated by CocoaPods.

It’s possible that your .xcodeproj still contains a reference to the Pods folder. You can remove it by right-clicking the folder and selecting ‘delete’. It will be gone instantly.

## Add Swift Package Manager

Now that you are free of CocoaPods, you can open and use the .xcodeproj. With It opened, to add a package you have to select the option “Add Package Dependency” in File > Swift Packages, and paste the URL of your dependency’s git repository. For example: https://github.com/kean/Nuke

<div align="center">
<img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/add_dependency.png?raw=true"/>
</div>

## Defining the libraries

so Now, We are gonna do rather than having each feature as a standalone Swift package, we are gonna define each feature in a single package with individual libraries.

Doing this way, allow us to build our features in insolation. So, using individual libraries, that allows me to build these targets with the source files in that folder.

To create the package, go to File -> New -> Package, define the name and do not forget to select the target in the Add To: and Group: options

<div align="center">
<img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/adding_package.png?raw=true"/>
</div>

After creating the package and adding the dependency packages that how the project navigation looks like:

<div align="center">
<img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/structure_folders_spm.png?raw=true"/>
</div>

Well, now inside the package you have a package file that you are gonna use to manage the dependencies, create the libraries and targets, configure resources and much more.

The folder structure on the left is my modular SpaceX with CocoaPods, and on the right is with SPM. As you can see, what before each feature and kit modules were targets linked directly to SpaceX, now with SPM they become libraries with each of them having your own target as well. For this to work, you must have to put the “target” folders inside the Sources folder like in the image below.

<div align="center">
<img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/comparing_structure_folders.png?raw=true"/>
</div>

Let’s take a peek inside of the package file. As you can see, that’s how I define the libraries and do not forget to put the target names the same as the folders shown in the previous image.

If your package has external dependencies like mine has with Nuke, just add it in the dependency Array specifying the GitHub url and the version number.

<div align="center">
<img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/package_file.png?raw=true"/>
</div>

Now to finish the package configuration, just create the targets for each folder that you put inside the source folder.

If your target depends on another target, you just have to define the dependency target name inside of the dependency array attribute. Launch depends on my others 2 targets and an external package “Nuke”, and you can see below how I declared as a dependency.

<div align="center">
<img src="https://github.com/Hugo-Coutinho/README-Assets/blob/master/SPM-Modular-SpaceX/package_file2.png?raw=true"/>
</div>

## Why Libraries and not multiple packages? 

Easier to maintain, I don’t need to maintain multiple Package.swift files instead I just have one that house everything.

And also as well, I don’t need to share each feature via hosting, these will be local to the project.



